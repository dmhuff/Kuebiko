/**
 * Kuebiko - NotePanel.java
 * Copyright 2011 Dave Huffman (daveh303 at yahoo dot com).
 * TODO license info.
 */

package com.jcap.view;

import java.awt.BorderLayout;
import java.awt.CardLayout;
import java.awt.Dimension;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;

import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.ImageIcon;
import javax.swing.JEditorPane;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.SwingConstants;
import javax.swing.event.CaretEvent;
import javax.swing.event.CaretListener;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.AttributeSet;
import javax.swing.text.Element;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;

import com.jcap.Main;
import com.jcap.model.Note;
import com.jcap.view.ImageManager.AppImage;

/**
 * UI panel for displaying and editing notes.
 *
 * @author davehuffman
 */
class NotePanel extends JPanel {
    private static final long serialVersionUID = 1L;
    
    /** 
     * Enumeration of CardLayout identifiers.
     * @see NotePanel#cardLayout
     */
    private enum CardId { NO_NOTE_MESSAGE, NOTE_TEXT }
    
    /** Enumeration of supported text styles for notes. */
    public enum TextStyle { 
        BOLD("font-bold"),
        ITALIC("font-italic"),
        UNDERLINE("font-underline");
        
        /** Identifier of the Swing action associated with this text style. */
        private final String actionName;
        
        private TextStyle(String actionName) {
            this.actionName = actionName;
        }
    }
    
    private final CardLayout cardLayout = new CardLayout();
    private final JToolBar editToolBar = new JToolBar();
    private final JEditorPane noteTextArea = new JEditorPane("text/html", "");
    
    /** The currently selected note. */
    private Note note;
    private boolean noteChanged = false;

    NotePanel() {
        initialize();
        additionalSetup();
    }

    /**
     * Initialize the contents of the frame. The contents of this method was 
     * generated by Window Builder Pro.
     */
    private void initialize() {
        setLayout(cardLayout);
        
        JLabel noSelectionLabel = new JLabel("No note selected"); // TODO i18n.
        noSelectionLabel.setHorizontalAlignment(SwingConstants.CENTER);
        add(noSelectionLabel, CardId.NO_NOTE_MESSAGE.toString());
        
        JPanel editNotePanel = new JPanel();
        add(editNotePanel, CardId.NOTE_TEXT.toString());
        editNotePanel.setLayout(new BorderLayout(0, 0));
        
        JScrollPane noteTextScrollPane = new JScrollPane();
        editNotePanel.add(noteTextScrollPane, BorderLayout.CENTER);
        noteTextScrollPane.setBorder(null);
        noteTextScrollPane.setViewportView(noteTextArea);
        
        editToolBar.setFocusable(false);
        editToolBar.setFloatable(false);
        editNotePanel.add(editToolBar, BorderLayout.NORTH);
    }
    
    /**
     * Perform additional setup to the frame. This is separate from the 
     * initialize() method so that the GUI builder doesn't mess with it.
     */
    private void additionalSetup() {
        // Edit Tool Bar.
        final ActionMap actionMap = noteTextArea.getActionMap();
        editToolBar.add(newToolBarButton(AppImage.BOLD, actionMap.get(TextStyle.BOLD.actionName)));
        editToolBar.add(newToolBarButton(AppImage.ITALIC, actionMap.get(TextStyle.ITALIC.actionName)));
        editToolBar.add(newToolBarButton(AppImage.UNDERLINE, actionMap.get(TextStyle.UNDERLINE.actionName)));
        editToolBar.add(newToolBarButton(AppImage.STRIKETHROUGH, null));
        
        // Note Editor Pane.
        noteTextArea.addCaretListener(new TextStyleCaretListener());
        this.addFocusListener(
                new FocusAdapter() {
                    @Override
                    public void focusGained(FocusEvent e) {
                        // When the panel gains focus, transfer focus to the
                        // note text area if it is visible.
                        if (noteTextArea.isVisible()) {
                            noteTextArea.requestFocusInWindow();
                        }
                    }
                });
        
        noteTextArea.getDocument().addDocumentListener(
                new DocumentListener() {
                    @Override
                    public void insertUpdate(DocumentEvent e) {
                        noteChanged = true;
                    }
        
                    @Override
                    public void removeUpdate(DocumentEvent e) {
                        noteChanged = true;
                    }
        
                    @Override
                    public void changedUpdate(DocumentEvent e) {
                        noteChanged = true;
                    }
                });
        
        
        // By default, no note should be displayed.
        setNote(null);
    }
    
    /**
     * Helper method. Instantiate and configure a toggle button for use in the 
     * note edit tool bar.
     * @param image Identifier for the button's image.
     * @param action The action to be associated with the button.
     * @return A newly created toggle button.
     */
    private JToggleButton newToolBarButton(AppImage image, Action action) {
        JToggleButton button = new JToggleButton(action);
        button.setIcon(new ImageIcon(ImageManager.get().getImage(image)));
        button.setText("");
        button.setPreferredSize(new Dimension(16, 16));
        button.setFocusable(false);
        return button;
    }

    /**
     * Handler for a note selection.
     * @param prevNote The previously displayed note.
     */
    private void onNoteSelected(Note prevNote) {
        Main.log("onNoteSelected(); [%s]", note);
        
        // Save any changes made to the previously selected note.
        if (prevNote != null && noteChanged) {
            prevNote.setText(noteTextArea.getText());
        }
        
        noteChanged = false;
        
        if (note == null) {
            cardLayout.show(this, CardId.NO_NOTE_MESSAGE.toString());
            return;
        }
        noteTextArea.setText(note.getText());
        cardLayout.show(this, CardId.NOTE_TEXT.toString());
    }
    
    JEditorPane getNoteTextArea() {
        return noteTextArea;
    }
    
    /**
     * @return The note currently displayed in the panel, or null if no note is
     *         being displayed.
     */
    public Note getNote() {
        return note;
    }

    /**
     * Assign a note to be displayed in the panel.
     * @param note The note to be displayed, or null if no note is to be 
     *             displayed.
     */
    public void setNote(Note note) {
        final Note prevNote = this.note;
        this.note = note;
        onNoteSelected(prevNote);
    }

    /**
     * Custom listener for caret updates; will toggle components for modifying 
     * text styles based on the text under the caret (a.k.a. cursor).
     * 
     * This class is based on the CaratHandler class in the SwingX JXEditorPane.
     * @see org.jdesktop.swingx.JXEditorPane.CaretHandler
     */
    private class TextStyleCaretListener implements CaretListener {
        @Override
        public void caretUpdate(CaretEvent event) {
            StyledDocument document = (StyledDocument) noteTextArea.getDocument();
            int dot = event.getDot();
            dot = dot > 0 ? dot - 1 : dot;
            
            Element elem = document.getCharacterElement(dot);
            AttributeSet set = elem.getAttributes();

            final ActionMap actionMap = noteTextArea.getActionMap();
            actionMap.get(TextStyle.BOLD.actionName).putValue(
                    Action.SELECTED_KEY, StyleConstants.isBold(set));
            actionMap.get(TextStyle.ITALIC.actionName).putValue(
                    Action.SELECTED_KEY, StyleConstants.isItalic(set));
            actionMap.get(TextStyle.UNDERLINE.actionName).putValue(
                    Action.SELECTED_KEY, StyleConstants.isUnderline(set));

            
            elem = document.getParagraphElement(dot);
            set = elem.getAttributes();

            // Update the paragraph selector if applicable.
//            if (selector != null) {
//                selector.setSelectedItem(set.getAttribute(StyleConstants.NameAttribute));
//            }

            switch (StyleConstants.getAlignment(set)) {
                // XXX There is a bug here. the setSelected method
                // should only affect the UI actions rather than propagate
                // down into the action map actions.
            case StyleConstants.ALIGN_LEFT:
//                manager.setSelected("left-justify", true);
                break;

            case StyleConstants.ALIGN_CENTER:
//                manager.setSelected("center-justify", true);
                break;

            case StyleConstants.ALIGN_RIGHT:
//                manager.setSelected("right-justify", true);
                break;
            }
        }
    }
}
